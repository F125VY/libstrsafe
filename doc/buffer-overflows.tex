\section{An introduction to buffer overflow attacks}
\subsection{What is a buffer overflow?}
Strings in programs are usually stored in a buffer as a series of characters,
ending with a \texttt{null} character to signify the end of the string.
In low level systems such as when programming in C,
there is usually no separate information on the length of the string.

When a string is copied into another string buffer,
the characters are simply copied until
the \texttt{null} character is located.
If this string won't fit in the memory area allocated at the destination,
the adjacent memory area might be overwritten.
This is known as a buffer overflow or buffer overrun.

A buffer overflow can be used to overwrite data used in the program,
but it can also be used to overwrite control data in the stack or heap
that stores the buffer.
This can enable the attacker to run arbritrary code on the system.

For example, by overwriting the return address of the current stack frame,
the overflow can enable the attacker to use any available data as code.
If the attacker fills a buffer with carefully chosen machine code,
known as shellcode,
and modifies the return address of the current stack frame
to jump to the buffer,
the chosen machine code will be run by the program.

By instead exploiting a buffer overflow on the heap,
the control structures for dynamic memory allocation are often overwritten.
By modifying the linked list used to keep track of
the dynamically allocated memory in many \texttt{malloc} implementations,
function pointers can later be overwritten to enable
execution of arbritrary code.

\subsection{How are buffer overflow attacks used?}
Buffer overflows are among the most usual sources of
security related bugs in software and
there are many well known examples of this.

Some examples of the use of buffer overflows include the
SQL Slammer\footnote{\url{http://www.cert.org/advisories/CA-2003-04.html}}
and Blaster\footnote{\url{http://www.cert.org/advisories/CA-2003-20.html}}
worms as well as jailbreaks
for the Apple iPhone\footnote{\url{http://support.apple.com/kb/HT4291}}
and Nintendo Wii.\footnote{\url{http://wiibrew.org/wiki/Twilight\_Hack}}

\subsection{Protecting against buffer overflow attacks}
There are several ways to protect software against buffer overflow attacks,
by modifying either the source code or
the execution environment that the software runs in.

\subsubsection{Protection in source code}
By checking the capacites of all involved buffers,
the risk for buffer overflows can be partially mitigated.
This does not eliminate the risk entirely though,
since some bugs may occur due to corner cases
such as integer calculation overflows when calculating capacities.

Safe coding practices can be used to check all capacities manually.
However, this can be a tedious workload and
programmers make mistakes,
so additional precautions are often required.

One way of reducing the workload is by using
safer string and buffer handling libraries.
Several such libraries are available for both C and C++. 
\strsafe is one of them.

Checking of buffer capacities is automatically enforced
by some programming environments.
Many languages that compile into bytecode such as Java,
and interpreted languages like Python or Ruby
check the capacities of buffers before reading or writing data.
This should be safe as long as no buffer overflow related bugs exist
in the runtime of the chosen language.

\subsubsection{Protection in the execution environment}
Another form of protection against buffer overflows can be achieved
by changing the execution environment used to run the software.

By using stack smashing protection, certain values known as
\emph{canary values} are inserted between data fields and
control structures of the stack.
When returning from a function call,
the canary value is examined for alteration.

The strategy of stack smashing protection only helps against
buffer overflows on the stack.
To protect data in the heap as well,
memory pages used for data in the stack and heap can be marked to
disallow execution of code on the page.
Execute space protection protects against user-supplied code
being run on the system,
but it will not protect against code that returns function calls to
the standard C libraries instead of the user's own shellcode.

% TODO Recheck facts and rewrite section about ASLR
Yet another strategy that can be employed in the execution environment
is address space layout randomization.
By randomizing the locations of the various memory areas used by software,
the difficulty in finding a suitable location to point to with function
pointers is increased.
To allow ordinary execution of software,
a translation step is added between the software and the operating system,
making the process transparent for software running from
position-independent executables.
